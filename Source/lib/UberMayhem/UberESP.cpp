#include "UberESP.h"

#if DEBUG
// Delay is there to mitigate issues with USB communication lockup on ESP32-S2 Mini
#define D_SerialBegin(...) Serial.begin(__VA_ARGS__)
#define D_write(...)       Serial.write(__VA_ARGS__)
#define D_print(...)       Serial.print(__VA_ARGS__); delay(10)
#define D_println(...)     Serial.println(__VA_ARGS__); delay(10)
#define D_printf(...)      Serial.printf(__VA_ARGS__); delay(10)
#else
#define D_SerialBegin(...)
#define D_write(...)
#define D_print(...)
#define D_println(...)
#define D_printf(...)
#endif

#ifndef PSY_ENABLE_SSL
// No SSL enabled
PsychicHttpServer       httpServer;
#else
// SSL enabled
#include "ssl_crt.h"     // SSL Certificate Public cert
#include "ssl_key.h"     // SSL Certificate Private key
PsychicHttpsServer      httpServer;
#endif

PsychicWebSocketHandler websocketHandler;
PsychicEventSource      eventSource;

#include "html_index.h"     // Index HTML file
#include "html_portapack.h" // Portapack HTML file

// -----------------------------------------------------------------------

// Convert Ascii-string to IPAddress-type
IPAddress atoip(const char* ipaddress) {
    unsigned int a, b, c, d;

    if (sscanf(ipaddress, "%u.%u.%u.%u", &a, &b, &c, &d) == 4)
        return IPAddress(a, b, c, d);

    return IPAddress(0, 0, 0, 0);
}

// Right-trim specific character
char* rtrim(char* string, char trim_char) {
    char* original = string + strlen(string);

    while (*--original == trim_char);
    *(original + 1) = '\0';

    return string;
}

// Generate Chip ID for ESP32 devices, like on ESP8266
uint32_t getChipId() {
  uint32_t chip_id = 0;

  for (int i = 0; i < 17; i = i + 8)
	  chip_id |= ((ESP.getEfuseMac() >> (40 - i)) & 0xff) << i;

  return chip_id;
}

// -----------------------------------------------------------------------
// Initialize library
// -----------------------------------------------------------------------
void UberESP::init() {
  EEPROM.begin(512);
  configLoad();

  inSafemode = safemodeCheck();

  // Start WIFI (incl. HTTP server)
  wifiStart();
}

// -----------------------------------------------------------------------
// EEPROM
// -----------------------------------------------------------------------
void UberESP::configLoad() {
  D_println("[ CONF ] Loading config from EEPROM");

  // Load config from EEPROM
  Config config_tmp;
  EEPROM.get(0, config_tmp);

  // Check that EEPROM config looks valid, otherwise continue to run on pre-made config
  if (strcmp(config_tmp.check, "CONF") == 0) {
    config = config_tmp;
  } else {
    D_println("[ CONF ] Error loading config from EEPROM, using defaults");
  }

  // If pre-defined values are missing, set autogenerated value
  if (strlen(config.deviceName) == 0)
    snprintf(config.deviceName, sizeof(config.deviceName)-1, "ESP_%06X", getChipId());
  if (strlen(config.deviceDesc) == 0)
    snprintf(config.deviceDesc, sizeof(config.deviceDesc)-1, "ESP_%06X", getChipId());

  int r, g, b;
  if (sscanf(config.ledColor, "%02x%02x%02x", &r, &g, &b) != 3)
    strlcpy(config.ledColor, CONF_LED_COLOR, sizeof(config.ledColor));
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void UberESP::configSave() {
  D_println("[ CONF ] Saving config to EEPROM");

  // Save config to EEPROM
  EEPROM.put(0, config);
  EEPROM.commit();
}

// -----------------------------------------------------------------------
// Safe-mode check
// -----------------------------------------------------------------------
bool UberESP::safemodeCheck() {
  // Check if safemode flag is set in EEPROM:
  //  1 = Safe mode on  : When ON... run in safemode to be able to flash a new firmware, but set it OFF for next boot
  //  0 = Safe mode off : When OFF.. run normally, but write safemode ON temporarily into EEPROM for SAFEMODE_TIMEOUT seconds
  //                      If we are still alive after timeout, everything should be OK. Reset safemode back to OFF for next boot

  // Read current safemode-status from EEPROM (last byte from address space)
  safemode_status = EEPROM.read(SAFEMODE_ADDRESS);

  // Invalid value
  if (safemode_status > 1) {
    safemode_status = 0;
  }

  if (safemode_status == 1) {
    // We are in safemode right now..
    // Only run safe operations until next boot
    D_println("[ SAFE ] Device is currently in SafeMode (something wrong?)");

    // Reset safemode to OFF for next boot
    EEPROM.write(SAFEMODE_ADDRESS, 0);
    EEPROM.commit();
  }

  if (safemode_status == 0) {
    // We are in normal mode right now..
    // Start a survival test
    
    // Set safemode temporarily to ON for SAFEMODE_TIMEOUT seconds, if we would crash..
    D_println("[ SAFE ] Set SafeMode temporarily to enabled (in case we don't survive boot)");
    EEPROM.write(SAFEMODE_ADDRESS, 1);
    EEPROM.commit();

    // If we survived and are still alive after timeout, reset safemode back to OFF again
    safemodeTimer.once(SAFEMODE_TIMEOUT, []() {
      D_println("[ SAFE ] Set SafeMode to disabled (we survived)");
      EEPROM.write(SAFEMODE_ADDRESS, 0);
      EEPROM.commit();
    });
  }

  return safemode_status;
}

// -----------------------------------------------------------------------
// WIFI
// -----------------------------------------------------------------------
void UberESP::wifiConnect() {
  if (!wifiConnecting) {

    // Start connecting every 1 minutes
    if (millis() - wifi_reconnect_timer > 1000 * 60 * 1 || wifi_reconnect_timer == 0) {

      // Configure WIFI with EspressIF IDF, instead av Arduino.h
      // Supports connecting to an AP with highest RSSI
      wifi_config_t wifi_config = {
          .sta = {
              .scan_method = WIFI_ALL_CHANNEL_SCAN, // WIFI_FAST_SCAN,
              .sort_method = WIFI_CONNECT_AP_BY_SIGNAL,
          }
      };
      strcpy((char *)wifi_config.sta.ssid, config.wifiSSID);
      strcpy((char *)wifi_config.sta.password, config.wifiPass);
      esp_wifi_set_config(WIFI_IF_STA, &wifi_config);

      // Start connecting to remote Accesspoint
      D_printf("[ WIFI ] Connecting to remote AP (SSID: %s)\r\n", config.wifiSSID);
      WiFi.begin();

      wifiConnecting = true;

      // Reset timers
      wifi_reconnect_timer  = millis();
      wifi_disconnect_timer = millis();
    }
  }

  if (wifiConnecting) {
    //if (WiFi.status() != WL_CONNECTED) {
    if (!WiFi.isConnected()) {
      // Process DNS requests
      DNS.processNextRequest();

      // Stop trying to connect if failed >10 sec
      if (millis() - wifi_disconnect_timer > 1000 * 10) {
        D_println("[ WIFI ] Timeout connecting to remote AP. Waiting a while until retry..");
        WiFi.disconnect(true);
        wifiConnecting = false;
      }

    } else {

      // Check if DHCP, otherwise use static IP
      if (config.netDHCP == true) {
        // Really needed at all?

        //D_println("[ WIFI ] Setting IP config to use DHCP");
        //WiFi.config(0u, 0u, 0u);
      } else {
        D_println("[ WIFI ] Setting static IP address");
        if ( !WiFi.config(config.netIP, config.netGW, config.netMask, config.netDNS) )
          D_println("[ WIFI ] Failed settings IP config");
      }

      // Do not stop SoftAP if we are in safemode..
      // ..since there can be a scenario where an invalid ipaddress is set and we can't reach it anymore
#if CONF_WIFI_AP_STOP
      if (!safemode_status) {
        // Stop DNS server
        DNS.stop();
        D_println("[ DNS  ] Stopped local DNS server");

        // Change to Station-mode only
        //WiFi.mode(WIFI_STA);
        WiFi.softAPdisconnect();
        D_println("[ WIFI ] Stopped local AP");
      }
#endif
      // We are connected to AP now
      wifiConnecting = false;
      vTaskDelete(taskWifiConnect);
    }
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void UberESP::wifiStart() {
  WiFi.setSleep(WIFI_PS_NONE);
  //WiFi.setSleep(WIFI_PS_MAX_MODEM);
  //WiFi.setSleep(false);

  // Event handler(s) for WIFI connection
  WiFi.onEvent( [&](WiFiEvent_t event, WiFiEventInfo_t info) { onWifiEvent(event); } );

  // Set device hostname
  WiFi.hostname(config.deviceName);

  // Set IP address to 10.0.0.1 for local accesspoint
  WiFi.softAPConfig(IPAddress(10,0,0,1), IPAddress(10,0,0,1), IPAddress(255,255,255,0));

  // Change to Accesspoint & Station-mode
  WiFi.mode(WIFI_AP_STA);

  // IMPORTANT!
  // Fix issue where AP mode completely stops working if ESPNow LongRange has been enabled
  //WiFi.softAPdisconnect(false);
  WiFi.enableAP(true);

  esp_wifi_set_bandwidth(WIFI_IF_AP, WIFI_BW_HT40);
  esp_wifi_set_bandwidth(WIFI_IF_STA, WIFI_BW_HT40);
  esp_wifi_set_protocol(WIFI_IF_AP, WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N);
  esp_wifi_set_protocol(WIFI_IF_STA, WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N);

  // Start own Accesspoint - it will stay in this mode until connection to another Accesspoint is successful
  WiFi.softAP(config.deviceName, (const char*)CONF_WIFI_AP_PASS);
  D_println("[ WIFI ] Started local AP (while connecting to remote AP)");

  // Start HTTP server
  httpStart();

  // Make all DNS requests go to local accesspoint IP (captive portal)
  DNS.start(53, "*", WiFi.softAPIP());
  D_println("[ DNS  ] Started local DNS server (captive portal)");

  // Non-blocking task to connect remote AP in the background
  // Create a background FreeRTOS task
  xTaskCreate(
      &UberESP::wifiConnectWrapper, // Function that should be called
      "taskWifiConnect",         // Name of the task (for debugging)
      2048,          // Stack size (bytes)
      this,          // Parameter to pass
      1,             // Task priority
      NULL           // Task handle
  );
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void UberESP::onWifiEvent(WiFiEvent_t event) {
  // Source:
  // https://docs.espressif.com/projects/esp-idf/en/release-v3.3/api-guides/wifi.html

  switch(event) {
    case SYSTEM_EVENT_WIFI_READY: {
    //case WIFI_EVENT_WIFI_READY: {
      D_println("[ WIFI ] Ready");

#if FEATURE_MQTT
      // Connect MQTT client if it has been configured
      if (mqttConfigured) mqttConnect();
#endif
      break;
    }

    case SYSTEM_EVENT_STA_DISCONNECTED: {
    //case WIFI_EVENT_STA_DISCONNECTED: {
      D_println("[ WIFI ] Connection to AP failed");
#if FEATURE_MQTT
      mqttReconnectTimer.detach();
#endif
      break;
    }

    case SYSTEM_EVENT_STA_GOT_IP: {
    //case IP_EVENT_STA_GOT_IP: {
      D_printf("[ WIFI ] Connected to remote AP with BSSID: %s\r\n", WiFi.BSSIDstr().c_str());

      D_print("[ WIFI ] Received IP config");
      D_print(" (MAC: ");
      D_print(WiFi.macAddress());
      D_print(" | IP: ");
      D_print(WiFi.localIP());
      D_print(" | GW: ");
      D_print(WiFi.gatewayIP());
      D_print(" | DNS: ");
      D_print(WiFi.dnsIP(0));
      D_println(")");

#if FEATURE_MQTT
      // Connect MQTT client if it has been configured
      if (mqttConfigured) mqttConnect();
#endif
      break;
    }

    case SYSTEM_EVENT_SCAN_DONE: {
    //case WIFI_EVENT_SCAN_DONE: {
      int16_t network_cnt = WiFi.scanComplete();

      D_print("[ WIFI ] Scan completed");

      if (network_cnt >= 0) {
        if (network_cnt == 0) {
            D_println(" - No networks found");
        } else {
          D_printf(" - %d networks found\r\n", network_cnt);

          // Print SSID and RSSI for each network found
          for (int i = 0; i < network_cnt; ++i) {
            D_printf("%2d: BSSID: %s RSSI: %d dBm (%d%%), %s %s\r\n",
              i + 1,
              WiFi.BSSIDstr(i).c_str(),
              WiFi.RSSI(i),
              constrain(2 * (WiFi.RSSI(i) + 100), 0, 100),
              (WiFi.encryptionType(i) == WIFI_AUTH_OPEN) ? " " : "*",
              WiFi.SSID(i).c_str()
            );
          }

          int i = 0;
          while (std::string(config.wifiSSID) != std::string(WiFi.SSID(i).c_str()) && (i < network_cnt)) {
            i++;
          }
        }
      }
      break;
    }

    default:
      break;
  }
}

#if FEATURE_MDNS
// -----------------------------------------------------------------------
// MDNS
// -----------------------------------------------------------------------
void UberESP::mdnsStart() {
  // Wait for MDNS responder to begin
  if (!MDNS.begin(config.deviceName)) {
    D_println("[ MDNS ] Error setting up MDNS service");
    while (1) {
      ESP.wdtFeed();    // TODO: Needed at all?
      delay(500);
    }
  }

  D_println("[ MDNS ] Started MDNS service");

  // Add service to MDNS-SD
  MDNS.addService("http", "tcp", 80);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void UberESP::mdnsHandler() {
  //MDNS.update(); // Not needed anymore since library update
}
#endif

// -----------------------------------------------------------------------
// HTTP
// -----------------------------------------------------------------------
void UberESP::setOnWsFrameCallback(void (*onWsFrameCallback_)(PsychicWebSocketRequest *request, httpd_ws_frame *frame)) {
  onWsFrameCallback = onWsFrameCallback_;
};

void UberESP::httpStart() {
  // Set header(s)
  DefaultHeaders::Instance().addHeader("Server", "PsychicHTTP");

#ifndef PSY_ENABLE_SSL
  // Start HTTP server
  httpServer.config.max_uri_handlers = 20;
  httpServer.listen(80);
#else
  // Optimize for SSL PSRAM
  #define MAX_HANDLER_COUNT 100
  #define MAX_HEADER_COUNT 50
  #define STACK_SIZE 5000

  httpServer.config.max_uri_handlers = MAX_HANDLER_COUNT;
  httpServer.config.stack_size = STACK_SIZE;
  httpServer.config.max_resp_headers = MAX_HEADER_COUNT;
  httpServer.config.lru_purge_enable = true;
  httpServer.config.enable_so_linger = false;
  httpServer.config.max_open_sockets = 13;

  httpServer.ssl_config.httpd.max_uri_handlers = MAX_HANDLER_COUNT;
  httpServer.ssl_config.httpd.stack_size = STACK_SIZE;
  httpServer.ssl_config.httpd.max_resp_headers = MAX_HEADER_COUNT;
  httpServer.ssl_config.httpd.lru_purge_enable = true;
  httpServer.ssl_config.httpd.enable_so_linger = false;
  httpServer.ssl_config.httpd.max_open_sockets = 13;

  // Start HTTPS server
  httpServer.ssl_config.httpd.max_uri_handlers = 20;
  httpServer.listen(443, SSL_CERT_CRT, SSL_CERT_KEY);

  // Redirect HTTP (80) -> HTTPS (443) with a 302 soft redirect
  PsychicHttpServer *redirectServer = new PsychicHttpServer();
  redirectServer->config.ctrl_port = 20420; // just a random port different from the default one
  redirectServer->listen(80);
  redirectServer->onNotFound([](PsychicRequest *request) {
    String url = "https://" + request->host() + request->url();

    PsychicResponse response(request);
    response.setCode(302);
    response.addHeader("Location", url.c_str());

    return response.send();
  });
#endif

  // Webpage handlers
  httpServer.on("/", HTTP_GET, [this](PsychicRequest *request) {
    return webpageIndex(request);
  });
  httpServer.on("/portapack", HTTP_GET, [this](PsychicRequest *request) {
    return webpagePortapack(request);
  });
  httpServer.on("/load", HTTP_GET, [this](PsychicRequest *request) {
    return request->reply(200, "application/json", getConfig().c_str() );
  });
  httpServer.on("/save", HTTP_POST, [this](PsychicRequest *request, JsonVariant &json) {
    setConfig(json);
    return request->reply(200, "text/html", "<meta http-equiv=\"refresh\" content=\"3; url=/\" />CONFIG SAVED!");
  });
  httpServer.on("/reboot", HTTP_GET, [this](PsychicRequest *request) {
    reboot();
    return request->reply(200, "text/html", "<meta http-equiv=\"refresh\" content=\"10; url=/\" />REBOOTING..");
  });
  httpServer.on("/sysinfo", HTTP_GET, [this](PsychicRequest *request) {
    return request->reply(200, "application/json", getSysinfo().c_str() );
  });
  httpServer.on("/wifiscan", HTTP_GET, [this](PsychicRequest *request) {
    return request->reply(200, "application/json", wifiScan().c_str() );
  });

  // Update | Upload firmware handler
  PsychicUploadHandler *uploadHandler = new PsychicUploadHandler();
  uploadHandler->onUpload([this](PsychicRequest *request, const String& filename, uint64_t index, uint8_t *data, size_t len, bool final) {
    return webpageUpdateUpload(request, filename, index, data, len, final);
  });
  uploadHandler->onRequest([this](PsychicRequest *request) {
    return webpageUpdateRequest(request);
  });
  httpServer.on("/update", HTTP_POST, uploadHandler);

  // Websocket handler (additional handler)
  websocketHandler.onOpen([](PsychicWebSocketClient *client) {
    D_printf("[ SOCK ] Connection #%u connected from %s\r\n", client->socket(), client->remoteIP().toString());
    //client->sendMessage("WS connected");
  });
  websocketHandler.onFrame([this](PsychicWebSocketRequest *request, httpd_ws_frame *frame) {
    D_printf("[ SOCK ] #%d sent: %s\r\n", request->client()->socket(), (char *)frame->payload);

    // Reboot
    if (strcasecmp((char *)frame->payload, "reboot") == 0)
      reboot();

    // Get Sysinfo
    if (strcasecmp((char *)frame->payload, "getSysinfo") == 0)
      return request->reply( (std::string("{\"espSysinfo\":") + getSysinfo() + "}").c_str() );

    // Get Config
    if (strcasecmp((char *)frame->payload, "getConfig") == 0)
      return request->reply( (std::string("{\"espConfig\":") + getConfig() + "}").c_str() );

    // Run user-defined callback
    if (onWsFrameCallback != nullptr)
       onWsFrameCallback(request, frame);

    return ESP_OK; // request->reply(frame);
  });
  websocketHandler.onClose([](PsychicWebSocketClient *client) {
    D_printf("[ SOCK ] connection #%u closed from %s\r\n", client->socket(), client->remoteIP().toString().c_str());
  });

  // EventSource handler (additional handler)
  eventSource.onOpen([](PsychicEventSourceClient *client) {
    client->send("Connected to /events", NULL, millis(), 1000);
  });

  // Add additional handlers to HTTP server
  httpServer.on("/ws", &websocketHandler);
  httpServer.on("/events", &eventSource);

  D_println("[ HTTP ] Started HTTP service");
}

// -----------------------------------------------------------------------
// WEB URL
// -----------------------------------------------------------------------
esp_err_t UberESP::webpageIndex(PsychicRequest *request) {
  // If wwwAuth is enabled, require user authentication
  if (config.wwwAuth == true && !request->authenticate(config.wwwUser, config.wwwPass))
    return request->requestAuthentication(BASIC_AUTH, "Config UI", "Login request");

  return request->reply(200, "text/html", HTML_INDEX);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void UberESP::reboot() {
    // Delay reboot with 2 seconds
    rebootTimer.once(2, []() {
      ESP.restart();
    });
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

std::string UberESP::getSysinfo() {
  // Create an JSON array
  JsonDocument jsonDoc;
  //SpiRamAllocator allocator;
  //JsonDocument jsonDoc(&allocator);

  char uptime[32];
  snprintf(uptime, sizeof(uptime)-1, "%dD %dH %dM %dS",
    (int) ((unsigned long)millis() / 1000 / 60 / 60 / 24),
    (int) ((unsigned long)millis() / 1000 / 60 / 60 % 24),
    (int) ((unsigned long)millis() / 1000 / 60 % 60),
    (int) ((unsigned long)millis() / 1000 % 60)
  );

  jsonDoc["Uptime"]              = uptime;
  jsonDoc["Wifi SSID"]           = WiFi.SSID();
  jsonDoc["Wifi BSSID"]          = WiFi.BSSIDstr();
  jsonDoc["Wifi RSSI"]           = WiFi.RSSI();
  jsonDoc["Wifi Channel"]        = WiFi.channel();
  jsonDoc["Flash Chip Size"]     = ESP.getFlashChipSize();
  jsonDoc["Flash Chip Speed"]    = ESP.getFlashChipSpeed();
  jsonDoc["Sketch Size"]         = ESP.getSketchSize();
  jsonDoc["Free Sketch Space"]   = ESP.getFreeSketchSpace();
  jsonDoc["CPU Freq MHz"]        = ESP.getCpuFreqMHz();
  jsonDoc["Mem Free Heap"]       = ESP.getFreeHeap();
  jsonDoc["Mem Free Psram"]      = ESP.getFreePsram();
  jsonDoc["SDK Version"]         = ESP.getSdkVersion();

  // Create message from JSON array
  std::string message;
  serializeJson(jsonDoc, message);

  return message;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

std::string UberESP::wifiScan() {
  // Create an JSON array
  JsonDocument jsonDoc;

  int16_t network_cnt = WiFi.scanComplete();

  // Check if scanning has finished or not
  if (network_cnt != -1 && network_cnt != -2) {
    // Create an JSON array with all the networks found
    if (network_cnt >= 0) {
      if (network_cnt == 0) {
        jsonDoc["status"] = "No networks found";

        D_printf("[ WIFI ] Started scan for APs\r\n");
        WiFi.scanNetworks(true);
      } else {
        jsonDoc["status"] = std::to_string(static_cast<int>(network_cnt)) + " networks found";

        for (int i = 0; i < network_cnt; ++i) {
          jsonDoc["ap"][i]["ssid"]     = WiFi.SSID(i);
          jsonDoc["ap"][i]["bssid"]    = std::string(WiFi.BSSIDstr(i).c_str());
          jsonDoc["ap"][i]["auth"]     = WiFi.encryptionType(i);
          jsonDoc["ap"][i]["rssi"]     = WiFi.RSSI(i),
          jsonDoc["ap"][i]["strength"] = constrain(2 * (WiFi.RSSI(i) + 100), 0, 100);
        }
      }
    }

  } else {

    // Scanning for SSID with highest RSSID
    if (network_cnt == -2) {
      D_printf("[ WIFI ] Started scan for APs\r\n");
      WiFi.scanNetworks(true);
    }
    jsonDoc["status"] = "Scanning";
  }

  // Create message from JSON array
  std::string message;
  serializeJson(jsonDoc, message);

  return message;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

std::string UberESP::getConfig() {
  // Load configuration from EEPROM
  configLoad();

  // Create an JSON array
  JsonDocument jsonDoc;
  
  jsonDoc["deviceName"]    = config.deviceName;
  jsonDoc["deviceDesc"]    = config.deviceDesc;
  jsonDoc["wwwAuth"]       = config.wwwAuth;
  jsonDoc["wwwUser"]       = config.wwwUser;
  jsonDoc["wwwPass"]       = config.wwwPass;
  jsonDoc["wifiSSID"]      = config.wifiSSID;
  jsonDoc["wifiPass"]      = config.wifiPass;
  jsonDoc["netDHCP"]       = config.netDHCP;
  if (config.netDHCP == true) {
    jsonDoc["netIP"]       = WiFi.localIP().toString();
    jsonDoc["netMask"]     = WiFi.subnetMask().toString();
    jsonDoc["netGW"]       = WiFi.gatewayIP().toString();
    jsonDoc["netDNS"]      = WiFi.dnsIP().toString();
  } else {
    jsonDoc["netIP"]       = config.netIP.toString();
    jsonDoc["netMask"]     = config.netMask.toString();
    jsonDoc["netGW"]       = config.netGW.toString();
    jsonDoc["netDNS"]      = config.netDNS.toString();
  }
  jsonDoc["netMAC"]        = std::string(WiFi.macAddress().c_str());
  jsonDoc["mqttServer"]    = config.mqttServer;
  jsonDoc["mqttPort"]      = config.mqttPort;
  jsonDoc["mqttUser"]      = config.mqttUser;
  jsonDoc["mqttPass"]      = config.mqttPass;
  jsonDoc["mqttHass"]      = config.mqttHass;      // true|false
  jsonDoc["mqttTopicHass"] = config.mqttTopicHass; // homeassistant
  jsonDoc["mqttTopicRoot"] = config.mqttTopicRoot; // esp32
  jsonDoc["mqttTopicSub"]  = config.mqttTopicSub;  // set
  jsonDoc["mqttTopicPub"]  = config.mqttTopicPub;  // json|motion|state..
  jsonDoc["colorMode"]     = config.colorMode;     // rgb|hs|xy
  jsonDoc["ledPin"]        = CONF_LED_PIN;	        // config.ledPin;
  jsonDoc["ledCount"]      = CONF_LED_COUNT;	      // config.ledCount;
  jsonDoc["ledBrightness"] = config.ledBrightness;
  jsonDoc["ledColor"]      = config.ledColor;

  jsonDoc["version"]       = CONF_VERSION_MIN;
  jsonDoc["safemode"]      = safemode_status;      // 0|1

  // Create message from JSON array
  std::string message;
  serializeJson(jsonDoc, message);

  return message;
};

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void UberESP::setConfig(JsonVariant &json) {

  JsonObject jsonObj = json.as<JsonObject>();

  // Parse POST-request and change config values accordingly

  // Since "checkbox" arguments are not sent by web-browser when set to false,
  // set to false first and let it prove the opposite
  config.netDHCP  = false;
  config.wwwAuth  = false;
  config.mqttHass = false;

  if ( jsonObj["deviceName"   ].is<const char*>() ) { strlcpy(config.deviceName, jsonObj["deviceName"], sizeof(config.deviceName)); }
  if ( jsonObj["deviceDesc"   ].is<const char*>() ) { strlcpy(config.deviceDesc, jsonObj["deviceDesc"], sizeof(config.deviceDesc)); }
  if ( jsonObj["wwwAuth"      ].is<const char*>() ) { config.wwwAuth = (strcasecmp(jsonObj["wwwAuth"], "true") == 0); }
  if ( jsonObj["wwwUser"      ].is<const char*>() ) { strlcpy(config.wwwUser, jsonObj["wwwUser"], sizeof(config.wwwUser)); }
  if ( jsonObj["wwwPass"      ].is<const char*>() ) { strlcpy(config.wwwPass, jsonObj["wwwPass"], sizeof(config.wwwPass)); }
  if ( jsonObj["wifiSSID"     ].is<const char*>() ) { strlcpy(config.wifiSSID, jsonObj["wifiSSID"], sizeof(config.wifiSSID)); }
  if ( jsonObj["wifiPass"     ].is<const char*>() ) { strlcpy(config.wifiPass, jsonObj["wifiPass"], sizeof(config.wifiPass)); }
  if ( jsonObj["netDHCP"      ].is<const char*>() ) { config.netDHCP = (strcasecmp(jsonObj["netDHCP"], "true") == 0); }
  if ( jsonObj["netIP"        ].is<const char*>() ) { config.netIP = atoip(jsonObj["netIP"]); }
  if ( jsonObj["netGW"        ].is<const char*>() ) { config.netGW = atoip(jsonObj["netGW"]); }
  if ( jsonObj["netMask"      ].is<const char*>() ) { config.netMask = atoip(jsonObj["netMask"]); }
  if ( jsonObj["netDNS"       ].is<const char*>() ) { config.netDNS = atoip(jsonObj["netDNS"]); }
  if ( jsonObj["mqttServer"   ].is<const char*>() ) { strlcpy(config.mqttServer, jsonObj["mqttServer"], sizeof(config.mqttServer)); }
  if ( jsonObj["mqttPort"     ].is<const char*>() && (unsigned)strlen(jsonObj["mqttPort"]) != 0) { config.mqttPort = (uint16_t)jsonObj["mqttPort"]; }
  if ( jsonObj["mqttUser"     ].is<const char*>() ) { strlcpy(config.mqttUser, jsonObj["mqttUser"], sizeof(config.mqttUser)); }
  if ( jsonObj["mqttPass"     ].is<const char*>() ) { strlcpy(config.mqttPass, jsonObj["mqttPass"], sizeof(config.mqttPass)); }
  if ( jsonObj["mqttHass"     ].is<const char*>() ) { config.mqttHass = (strcasecmp(jsonObj["mqttHass"], "true") == 0); }
  if ( jsonObj["mqttTopicHass"].is<const char*>() && (unsigned)strlen(jsonObj["mqttTopicHass"]) != 0) { strlcpy(config.mqttTopicHass, jsonObj["mqttTopicHass"], sizeof(config.mqttTopicHass)); }
  if ( jsonObj["mqttTopicRoot"].is<const char*>() && (unsigned)strlen(jsonObj["mqttTopicRoot"]) != 0) { strlcpy(config.mqttTopicRoot, jsonObj["mqttTopicRoot"], sizeof(config.mqttTopicRoot)); }
  if ( jsonObj["mqttTopicSub" ].is<const char*>() ) { strlcpy(config.mqttTopicSub, jsonObj["mqttTopicSub"], sizeof(config.mqttTopicSub)); }
  if ( jsonObj["mqttTopicPub" ].is<const char*>() ) { strlcpy(config.mqttTopicPub, jsonObj["mqttTopicPub"], sizeof(config.mqttTopicPub)); }
  if ( jsonObj["colorMode"    ].is<const char*>() ) { strlcpy(config.colorMode, jsonObj["colorMode"], sizeof(config.colorMode)); }
  if ( jsonObj["ledColor"     ].is<const char*>() ) { strlcpy(config.ledColor, jsonObj["ledColor"], sizeof(config.ledColor)); }
  if ( jsonObj["ledBrightness"].is<const char*>() && (unsigned)strlen(jsonObj["ledBrightness"]) != 0) { config.ledBrightness = (uint16_t)jsonObj["ledBrightness"]; }

  // Save configuration to EEPROM
  configSave();
};

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

esp_err_t UberESP::webpagePortapack(PsychicRequest *request) {
  return request->reply(200, "text/html", HTML_PORTAPACK);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// Upload finished
esp_err_t UberESP::webpageUpdateRequest(PsychicRequest *request) {
  if (!Update.hasError()) {
    // Update OK
    PsychicResponse response(request);
    response.setCode(302);
    response.addHeader("Location", "/reboot");

    return response.send();
    //return request->reply(200, "text/html", "<meta http-equiv=\"refresh\" content=\"10; url=/\" />REBOOTING..");
  } else {
    // Update Failed
    std::string error = "UPDATE FAILED! " + getUpdateError();
    Update.clearError();

    return request->reply(200, "text/html", error.c_str());
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// Upload in progress
esp_err_t UberESP::webpageUpdateUpload(PsychicRequest *request, const String& filename, uint64_t index, uint8_t *data, size_t len, bool final) {
  if (!Update.hasError()) {
    // No errors

    // Begin update
    if (!index) {
      // First chunk, clear errors, if any
      //Update.clearError();

      if (!Update.begin(UPDATE_SIZE_UNKNOWN, U_FLASH)) {
        // Something went wrong
        if (!Update.hasError()) Update.abort();
        Update.printError(Serial);
        return ESP_FAIL;
      }
    }

    // Ongoing update, if no error encountered
    if (len && !Update.hasError()) {
      if (Update.write(data, len) != len) {
        if (!Update.hasError()) Update.abort();
        Update.printError(Serial);
        return ESP_FAIL;
      }
    }

    // Final update, if no error encountered
    if (final && !Update.hasError()) {
      if (Update.end(true)) {
        Serial.println("Update completed");
        Serial.flush();
      } else {
        if (!Update.hasError()) Update.abort();
        Update.printError(Serial);
        return ESP_FAIL;
      }
    }

    return ESP_OK;
  } else {
    return ESP_FAIL;
  }
}

#if FEATURE_MQTT
// -----------------------------------------------------------------------
// MQTT
// -----------------------------------------------------------------------
void UberESP::setOnMqttConnectCallback(void (*onMqttConnectCallback_)()) {
  onMqttConnectCallback = onMqttConnectCallback_;
};
void UberESP::setOnMqttMessageCallback(void (*onMqttMessageCallback_)(const char *, const char *)) {
  onMqttMessageCallback = onMqttMessageCallback_;
};

void UberESP::mqttStart() {
  // Verify that MQTT server and port are valid
  if (strlen(config.mqttServer) == 0)
    return;

  if (config.mqttPort < 1 || config.mqttPort > 65535)
    return;

  // Generate extended MQTT topics for: root, sub and pub
  // These are saved in global variables used by other methods
  sprintf(mqtt_fulltopic_root, "%s/%s", config.mqttTopicRoot, config.deviceName);
  sprintf(mqtt_fulltopic_sub, "%s/+/%s", mqtt_fulltopic_root, config.mqttTopicSub);
  sprintf(mqtt_fulltopic_pub, "%s/%s", mqtt_fulltopic_root, config.mqttTopicPub);

  // Event handlers
  mqttClient.onConnect([&](bool sessionPresent) { onMqttConnect(sessionPresent); });
  mqttClient.onDisconnect([&](AsyncMqttClientDisconnectReason reason) { onMqttDisconnect(reason); });
  mqttClient.onMessage([&](char* topic, char* payload, AsyncMqttClientMessageProperties properties, size_t length, size_t index, size_t total) {
    onMqttMessage(topic, payload, properties, length, index, total);
  });

  //mqttClient.onPublish(onMqttPublish);
  //mqttClient.onSubscribe(onMqttSubscribe);
  //mqttClient.onUnsubscribe(onMqttUnsubscribe);

  // Start MQTT server
  mqttClient.setServer(config.mqttServer, config.mqttPort);

  if (strlen(config.mqttUser) > 0)
    mqttClient.setCredentials(config.mqttUser, config.mqttPass);

  D_println("[ MQTT ] Configured MQTT client settings");

  mqttConfigured = true;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void UberESP::mqttConnect() {
  D_printf("[ MQTT ] Connnecting to MQTT server (%s:%d)\r\n", config.mqttServer, config.mqttPort);
  mqttReconnectTimer.detach();
  mqttClient.connect();
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void UberESP::onMqttConnect(bool sessionPresent) {
  D_println("[ MQTT ] Connected to MQTT server");
  
  // Start MQTT subscribe
  mqttClient.subscribe(mqtt_fulltopic_sub, 0);

  // Publish initial messages when connected
  mqttPublishStartup();
    
  // Run user-defined callback
  if (onMqttConnectCallback != nullptr)
    onMqttConnectCallback();
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void UberESP::onMqttDisconnect(AsyncMqttClientDisconnectReason reason) {
  D_println("[ DEBUG ] Clearing MQTT queue");
  mqttClient.clearQueue();

  D_println("[ MQTT ] Disconnected from MQTT server");

  if (WiFi.isConnected()) {
    D_println("[ DEBUG ] Start MQTT connection timer..");
    mqttReconnectTimer.once(2, +[](UberESP* timerInstance) { timerInstance->mqttConnect(); }, this);
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void UberESP::onMqttMessage(char* topic, char* payload, AsyncMqttClientMessageProperties properties, size_t length, size_t index, size_t total) {
  /*
  D_println(topic);
  D_println(properties.qos);
  D_println(properties.dup);
  D_println(properties.retain);
  D_println(length);
  D_println(index);
  D_println(total);
  */

  // Split to topic at each '/' and save the last-1 topic as sub_topic
  char sub_topic[strlen(topic) + 1];
  for (char *p = strtok(topic, "/"); p != NULL; p = strtok(NULL, "/")) {
    if (p != NULL && strcmp(p, config.mqttTopicSub) != 0)
      strcpy(sub_topic, p);
  }

  char message[length+1];
  for (unsigned int i = 0; i < length; i++) {
    message[i] = (char)payload[i];
  }
  message[length] = '\0';

  // Topic matches
  //if (strcmp(topic, mqtt_fulltopic_sub) == 0)

  // Run user-defined parser
  if (onMqttMessageCallback != nullptr)
    onMqttMessageCallback(sub_topic, message);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

/*
void UberESP::onMqttPublish(uint16_t packetId) {
  //D_println(packetId);
}

void UberESP::onMqttSubscribe(uint16_t packetId, uint8_t qos) {
  //D_println(packetId);
  //D_println(qos);
}

void UberESP::onMqttUnsubscribe(uint16_t packetId) {
  //D_println(packetId);
}
*/

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void UberESP::mqttPublishStartup() {
  // Publish startup message
  char startup_topic[strlen(mqtt_fulltopic_root) + 8];
  char startup_message[sizeof(CONF_VERSION)-1 + strlen(config.deviceDesc) + 128];

  snprintf(startup_topic,   sizeof(startup_topic  )-1, "%s/info", mqtt_fulltopic_root);
  snprintf(startup_message, sizeof(startup_message)-1, "{\"ip\":\"%s\", \"unique_id\":\"ESP_%06X\", \"version\":\"%s\", \"description\":\"%s\"}", WiFi.localIP().toString().c_str(), getChipId(), CONF_VERSION, config.deviceDesc);

  mqttClient.publish(startup_topic, 0, true, startup_message);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void UberESP::mqttPublishHassAutodiscover(const char* entity_type, const char* sub_topic, const char* unit, const char* custom_json) {
  if (config.mqttHass) {

    // Device Id
    char device_id[32];
    snprintf(device_id, sizeof(device_id)-1, "%s", config.deviceName);

    // Unique Id
    char unique_id[32];
    snprintf(unique_id, sizeof(unique_id)-1, "ESP_%06X_%i", getChipId(), mqtt_hass_autoconfig_id);

    // Autodiscover topic
    char autodiscover_topic[sizeof(config.mqttTopicHass) + strlen(entity_type) + sizeof(unique_id) + 36];
    if (strcmp(entity_type, "trigger") == 0)
      snprintf(autodiscover_topic, sizeof(autodiscover_topic)-1, "%s/device_automation/%s/action_%s/config", config.mqttTopicHass, unique_id, sub_topic);
    else
      snprintf(autodiscover_topic, sizeof(autodiscover_topic)-1, "%s/%s/%s/config", config.mqttTopicHass, entity_type, unique_id);

    // Display name
    char displayname[sizeof(config.deviceDesc) + strlen(sub_topic) + 4];

    // Check if "value_json.<entity name>" is used, in that case grab entity name from there
    char *p = strstr(custom_json, "value_json.");
    if (p != NULL) {
      // Forward character pointer to where entity name begins (11 chars)
      p += 11;

      int i = 0;
      char entity_displayname[strlen(custom_json) - 10];

      // Stop scanning if any of these characters are not found: 0-9 a-z A-Z _
      while ( (p[i] != '\0') && ((p[i] >= 65 && p[i] <= 90) || (p[i] >= 97 && p[i] <= 122) || (p[i] >=48 && p[i] <= 57) || p[i] == 95) ) {
        entity_displayname[i] = p[i];
        ++i;
      }
      entity_displayname[i] = '\0';

      // Grab entity name from value_template
      //sprintf(displayname, "%s (%s)", config.deviceDesc, entity_displayname);
      snprintf(displayname, sizeof(displayname)-1, "(%s)", entity_displayname);
    } else if (strlen(sub_topic) > 0) {
      // Grab entity name from sub_topic variable
      //sprintf(displayname, "%s (%s)", config.deviceDesc, sub_topic);
      snprintf(displayname, sizeof(displayname)-1, "(%s)", sub_topic);
    } else {
      // No entity name at all
      snprintf(displayname, sizeof(displayname)-1, "%s", config.deviceDesc);
    }

    // Base topic (~)
    char base_topic[sizeof(config.mqttTopicRoot) + sizeof(device_id) + strlen(sub_topic) + 10];
    snprintf(base_topic, sizeof(base_topic)-1, "%s/%s/%s", config.mqttTopicRoot, device_id, sub_topic);
    rtrim(base_topic, '/');

    // State topic
    char state_topic[sizeof(config.mqttTopicPub) + 4];
    snprintf(state_topic, sizeof(state_topic)-1, "~/%s", config.mqttTopicPub);
    rtrim(state_topic, '/');

    // Command topic
    char command_topic[sizeof(config.mqttTopicSub) + 4];
    snprintf(command_topic, sizeof(command_topic)-1, "~/%s", config.mqttTopicSub);
    rtrim(command_topic, '/');

    // Create a JSON-array to configure the entity
    JsonDocument jsonDoc;

    // Append custom autodiscover JSON-config
    deserializeJson(jsonDoc, custom_json);

    jsonDoc["uniq_id"] = unique_id;
    jsonDoc["name"] = displayname;
    jsonDoc["~"] = base_topic;

    // Sensor
    if (strcmp(entity_type, "sensor") == 0) {
      jsonDoc["state_topic"] = state_topic;
      if (strlen(unit) > 0)
        jsonDoc["unit_of_measurement"] = (const char*)unit;
    }

    // Binary Sensor
    if (strcmp(entity_type, "binary_sensor") == 0) {
      jsonDoc["state_topic"] = state_topic;
    }

    // Switch
    if (strcmp(entity_type, "switch") == 0) {
      jsonDoc["state_topic"] = state_topic;
      jsonDoc["command_topic"] = command_topic;
      jsonDoc["optimistic"] = "true"; //"false";
    }

    // Button
    if (strcmp(entity_type, "button") == 0) {
      jsonDoc["command_topic"] = command_topic;
    }

    // Trigger
    if (strcmp(entity_type, "trigger") == 0) {
      // Change topic
      jsonDoc["automation_type"] = "trigger";
      jsonDoc["topic"] = "~/action";
      jsonDoc["type"] = "action";
      jsonDoc["sub_type"] = (const char*)sub_topic;
    }

    // Light
    if (strcmp(entity_type, "light") == 0) {
      jsonDoc["state_topic"] = state_topic;
      jsonDoc["command_topic"] = command_topic;
      jsonDoc["optimistic"] = "false";
      jsonDoc["schema"] = "json";
      jsonDoc["brightness"] = "true";
      jsonDoc["effect"] = "true";
      jsonDoc["effect_list"] = serialized(CONF_LED_EFFECTS);
      jsonDoc["supported_color_modes"] = serialized("[\"rgb\",\"hs\",\"xy\"]");
    }

    // Number
    if (strcmp(entity_type, "number") == 0) {
      jsonDoc["state_topic"] = state_topic;
      jsonDoc["command_topic"] = command_topic;
    }

    // Device specific info
    JsonObject jsonDocDevice           = jsonDoc["device"].to<JsonObject>();
    JsonArray jsonDocDeviceIdentifiers = jsonDocDevice["identifiers"].to<JsonArray>();

    jsonDocDeviceIdentifiers.add(device_id);
    jsonDocDevice["name"]         = config.deviceDesc;
    jsonDocDevice["sw_version"]   = CONF_VERSION;
    jsonDocDevice["model"]        = "ESP32 Device";
    jsonDocDevice["manufacturer"] = "Ubermood";

    // Configuration URL to the ESP device
    char configuration_url[32];
    snprintf(configuration_url, sizeof(configuration_url), "http://%s/", WiFi.localIP().toString().c_str());
    jsonDocDevice["configuration_url"] = configuration_url;

    // Create MQTT message from JSON array
    char message[measureJson(jsonDoc) + 1];
    serializeJson(jsonDoc, message, sizeof(message));

    // Publish MQTT autodiscover message
    mqttClient.publish(autodiscover_topic, 0, true, message);

    // Increase ID to maintain unique config topic & id
    mqtt_hass_autoconfig_id++;
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void UberESP::mqttPublish(const char* sub_topic, const char* message) {
  char publish_topic[sizeof(mqtt_fulltopic_root) + strlen(sub_topic) + sizeof(config.mqttTopicPub) + 4];

  if (strlen(sub_topic) > 0)
    snprintf(publish_topic, sizeof(publish_topic)-1, "%s/%s/%s", mqtt_fulltopic_root, sub_topic, config.mqttTopicPub);
  else
    snprintf(publish_topic, sizeof(publish_topic)-1, "%s/%s", mqtt_fulltopic_root, config.mqttTopicPub);

  rtrim(publish_topic, '/');

  if (mqttClient.connected())
    mqttClient.publish(publish_topic, 0, false, message);
}
#endif

// -----------------------------------------------------------------------
// Logging
// -----------------------------------------------------------------------
// Convert ESP-updater error stream to a c_string
std::string UberESP::getUpdateError() {
  StreamString updateErrorStream;
  Update.printError(updateErrorStream);

  return updateErrorStream.c_str();
}

void UberESP::sendWsAll(const char *message, size_t len){
  websocketHandler.sendAll(HTTPD_WS_TYPE_TEXT, message, len);
}

void UberESP::wsPrintf(const char *format, ...) {
  char message[256];
  va_list args;
  va_start(args, format);
  vsnprintf(message, sizeof(message), format, args);
  va_end(args);

  websocketHandler.sendAll(message);
}

void UberESP::eventPrintf(const char *format, ...) {
  char message[256];
  va_list args;
  va_start(args, format);
  vsnprintf(message, sizeof(message), format, args);
  va_end(args);

  eventSource.send(message, "log", millis(), 1000);
}

void UberESP::eventPrint(const char* message) {
  eventSource.send(message, "log", millis(), 1000);
}